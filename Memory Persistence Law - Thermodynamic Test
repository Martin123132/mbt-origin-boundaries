<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Persistence Law - Thermodynamic Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
        }
        
        .control-group h3 {
            margin-top: 0;
            color: #ffd700;
        }
        
        .slider-container {
            margin: 15px 0;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .slider {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            outline: none;
            margin-bottom: 5px;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #ffd700;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .value-display {
            color: #ffd700;
            font-weight: bold;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.2s;
            margin: 5px;
        }
        
        button:hover {
            transform: scale(1.05);
        }
        
        .results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            min-height: 300px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ffd700;
        }
        
        .stat-label {
            font-size: 0.9rem;
            margin-top: 5px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Memory Persistence Law - Phase Transition Test</h1>
            <p>Testing M = (1 - C) × P × c²_echo vs Standard Thermodynamics</p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h3>System Parameters</h3>
                <div class="slider-container">
                    <label for="temperature">Temperature: <span id="temp-value" class="value-display">300 K</span></label>
                    <input type="range" id="temperature" class="slider" min="250" max="400" value="300">
                </div>
                <div class="slider-container">
                    <label for="presence">Presence Intensity (P): <span id="presence-value" class="value-display">1.0</span></label>
                    <input type="range" id="presence" class="slider" min="0.1" max="2.0" step="0.1" value="1.0">
                </div>
                <div class="slider-container">
                    <label for="echo">Echo Transmissibility (c_echo): <span id="echo-value" class="value-display">1.0</span></label>
                    <input type="range" id="echo" class="slider" min="0.5" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
            
            <div class="control-group">
                <h3>Phase Transition</h3>
                <div class="slider-container">
                    <label for="phase-rate">Transition Rate: <span id="rate-value" class="value-display">0.1</span></label>
                    <input type="range" id="phase-rate" class="slider" min="0.01" max="0.5" step="0.01" value="0.1">
                </div>
                <button onclick="runSimulation()">Run Phase Transition Simulation</button>
                <button onclick="compareModels()">Compare MBT vs Standard</button>
                <button onclick="resetSimulation()">Reset</button>
            </div>
        </div>
        
        <div class="results">
            <div class="chart-container">
                <canvas id="memoryChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="entropyChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="coherenceChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="comparisonChart"></canvas>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="final-memory">0.0</div>
                <div class="stat-label">Final Memory</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="max-entropy">0.0</div>
                <div class="stat-label">Max Entropy</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="coherence-loss">0.0</div>
                <div class="stat-label">Coherence Loss</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="reorder-events">0</div>
                <div class="stat-label">Reorder Events</div>
            </div>
        </div>
    </div>

    <script>
        // Global variables for charts
        let memoryChart, entropyChart, coherenceChart, comparisonChart;
        
        // Simulation data
        let timeSteps = [];
        let memoryData = [];
        let entropyData = [];
        let coherenceData = [];
        let standardData = [];
        let mbtData = [];
        
        // Initialize charts
        function initCharts() {
            const chartOptions = {
                responsive: true,
                plugins: {
                    legend: {
                        labels: { color: 'white' }
                    }
                },
                scales: {
                    x: { 
                        ticks: { color: 'white' },
                        grid: { color: 'rgba(255,255,255,0.2)' }
                    },
                    y: { 
                        ticks: { color: 'white' },
                        grid: { color: 'rgba(255,255,255,0.2)' }
                    }
                }
            };
            
            memoryChart = new Chart(document.getElementById('memoryChart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Memory Persistence (M)',
                        data: [],
                        borderColor: '#ffd700',
                        backgroundColor: 'rgba(255, 215, 0, 0.1)',
                        tension: 0.4
                    }]
                },
                options: { ...chartOptions, plugins: { ...chartOptions.plugins, title: { display: true, text: 'Memory Persistence Over Time', color: 'white' } } }
            });
            
            entropyChart = new Chart(document.getElementById('entropyChart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'System Entropy',
                        data: [],
                        borderColor: '#ff6b6b',
                        backgroundColor: 'rgba(255, 107, 107, 0.1)',
                        tension: 0.4
                    }]
                },
                options: { ...chartOptions, plugins: { ...chartOptions.plugins, title: { display: true, text: 'Entropy Evolution', color: 'white' } } }
            });
            
            coherenceChart = new Chart(document.getElementById('coherenceChart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Coherence (1-C)',
                        data: [],
                        borderColor: '#4ecdc4',
                        backgroundColor: 'rgba(78, 205, 196, 0.1)',
                        tension: 0.4
                    }]
                },
                options: { ...chartOptions, plugins: { ...chartOptions.plugins, title: { display: true, text: 'System Coherence', color: 'white' } } }
            });
            
            comparisonChart = new Chart(document.getElementById('comparisonChart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Standard Thermodynamics',
                            data: [],
                            borderColor: '#ff9999',
                            backgroundColor: 'rgba(255, 153, 153, 0.1)',
                            tension: 0.4
                        },
                        {
                            label: 'MBT Prediction',
                            data: [],
                            borderColor: '#99ff99',
                            backgroundColor: 'rgba(153, 255, 153, 0.1)',
                            tension: 0.4
                        }
                    ]
                },
                options: { ...chartOptions, plugins: { ...chartOptions.plugins, title: { display: true, text: 'Model Comparison', color: 'white' } } }
            });
        }
        
        // Update slider displays
        function updateSliderDisplays() {
            document.getElementById('temp-value').textContent = document.getElementById('temperature').value + ' K';
            document.getElementById('presence-value').textContent = document.getElementById('presence').value;
            document.getElementById('echo-value').textContent = document.getElementById('echo').value;
            document.getElementById('rate-value').textContent = document.getElementById('phase-rate').value;
        }
        
        // Memory Persistence Law calculation
        function calculateMemoryPersistence(coherenceCollapse, presenceIntensity, echoTransmissibility) {
            return (1 - coherenceCollapse) * presenceIntensity * Math.pow(echoTransmissibility, 2);
        }
        
        // Coherence collapse as function of entropy and time
        function calculateCoherenceCollapse(entropy, time, temperature) {
            // C increases with entropy and time, but temperature can provide resistance
            const baseCollapse = 1 - Math.exp(-entropy * time / 100);
            const tempResistance = Math.exp(-temperature / 1000);
            return Math.min(0.95, baseCollapse * (1 + tempResistance));
        }
        
        // Standard thermodynamic entropy evolution
        function standardEntropy(time, temperature, phaseRate) {
            // Simple model: entropy increases during phase transition then stabilizes
            const transitionPoint = 50;
            if (time < transitionPoint) {
                return time * phaseRate * (400 - temperature) / 400;
            } else {
                return transitionPoint * phaseRate * (400 - temperature) / 400 + 
                       Math.log(time - transitionPoint + 1) * 0.1;
            }
        }
        
        // MBT entropy with reordering - FIXED FUNCTION NAME
        function calculateMbtEntropy(time, temperature, phaseRate, currentEntropy) {
            // MBT allows for entropy reduction during reordering events
            const standardIncrease = phaseRate * (400 - temperature) / 400;
            
            // Reordering events every ~25 time steps
            const reorderCycle = 25;
            const cyclePosition = time % reorderCycle;
            
            if (cyclePosition < 5) {
                // Reordering phase - entropy can decrease
                return Math.max(0, currentEntropy - standardIncrease * 2);
            } else {
                // Normal increase
                return currentEntropy + standardIncrease;
            }
        }
        
        // Run main simulation
        function runSimulation() {
            const temperature = parseFloat(document.getElementById('temperature').value);
            const presence = parseFloat(document.getElementById('presence').value);
            const echo = parseFloat(document.getElementById('echo').value);
            const phaseRate = parseFloat(document.getElementById('phase-rate').value);
            
            // Reset data arrays
            timeSteps = [];
            memoryData = [];
            entropyData = [];
            coherenceData = [];
            
            let currentEntropy = 0.1;
            let reorderCount = 0;
            
            // Simulate 100 time steps
            for (let t = 0; t <= 100; t++) {
                timeSteps.push(t);
                
                // Calculate entropy using MBT model
                const newEntropy = calculateMbtEntropy(t, temperature, phaseRate, currentEntropy);
                if (newEntropy < currentEntropy) reorderCount++;
                currentEntropy = newEntropy;
                entropyData.push(currentEntropy);
                
                // Calculate coherence collapse
                const coherenceCollapse = calculateCoherenceCollapse(currentEntropy, t, temperature);
                const coherence = 1 - coherenceCollapse;
                coherenceData.push(coherence);
                
                // Calculate memory persistence
                const memory = calculateMemoryPersistence(coherenceCollapse, presence, echo);
                memoryData.push(memory);
            }
            
            // Update charts
            updateChart(memoryChart, timeSteps, [memoryData], ['Memory Persistence (M)']);
            updateChart(entropyChart, timeSteps, [entropyData], ['System Entropy']);
            updateChart(coherenceChart, timeSteps, [coherenceData], ['Coherence (1-C)']);
            
            // Update stats
            document.getElementById('final-memory').textContent = memoryData[memoryData.length - 1].toFixed(3);
            document.getElementById('max-entropy').textContent = Math.max(...entropyData).toFixed(3);
            document.getElementById('coherence-loss').textContent = (1 - Math.min(...coherenceData)).toFixed(3);
            document.getElementById('reorder-events').textContent = reorderCount;
        }
        
        // Compare MBT vs Standard models
        function compareModels() {
            const temperature = parseFloat(document.getElementById('temperature').value);
            const phaseRate = parseFloat(document.getElementById('phase-rate').value);
            
            standardData = [];
            mbtData = [];
            
            let currentMbtEntropy = 0.1;
            
            for (let t = 0; t <= 100; t++) {
                // Standard thermodynamics - monotonic entropy increase
                const stdEntropy = standardEntropy(t, temperature, phaseRate);
                standardData.push(stdEntropy);
                
                // MBT - allows reordering
                currentMbtEntropy = calculateMbtEntropy(t, temperature, phaseRate, currentMbtEntropy);
                mbtData.push(currentMbtEntropy);
            }
            
            updateChart(comparisonChart, timeSteps.length ? timeSteps : Array.from({length: 101}, (_, i) => i), 
                        [standardData, mbtData], ['Standard Thermodynamics', 'MBT Prediction']);
        }
        
        // Update chart with new data
        function updateChart(chart, labels, datasets, datasetLabels) {
            chart.data.labels = labels;
            datasets.forEach((data, index) => {
                if (chart.data.datasets[index]) {
                    chart.data.datasets[index].data = data;
                    chart.data.datasets[index].label = datasetLabels[index];
                }
            });
            chart.update();
        }
        
        // Reset simulation
        function resetSimulation() {
            memoryChart.data.labels = [];
            memoryChart.data.datasets[0].data = [];
            entropyChart.data.labels = [];
            entropyChart.data.datasets[0].data = [];
            coherenceChart.data.labels = [];
            coherenceChart.data.datasets[0].data = [];
            comparisonChart.data.labels = [];
            comparisonChart.data.datasets.forEach(dataset => dataset.data = []);
            
            [memoryChart, entropyChart, coherenceChart, comparisonChart].forEach(chart => chart.update());
            
            document.getElementById('final-memory').textContent = '0.0';
            document.getElementById('max-entropy').textContent = '0.0';
            document.getElementById('coherence-loss').textContent = '0.0';
            document.getElementById('reorder-events').textContent = '0';
        }
        
        // Critical point test - where standard thermodynamics predicts divergence
        function testCriticalPoint() {
            console.log("Testing critical point behavior...");
            const criticalTemp = 374; // Water critical point
            const presence = parseFloat(document.getElementById('presence').value);
            const echo = parseFloat(document.getElementById('echo').value);
            
            // Reset arrays
            timeSteps = [];
            memoryData = [];
            entropyData = [];
            coherenceData = [];
            standardData = [];
            mbtData = [];
            
            let currentMbtEntropy = 0.1;
            let reorderCount = 0;
            
            for (let t = 0; t <= 100; t++) {
                timeSteps.push(t);
                
                // Temperature ramp towards critical point
                const currentTemp = 300 + (criticalTemp - 300) * (t / 100);
                
                // Standard model - diverges at critical point
                const stdEntropy = t < 90 ? t * 0.05 : Math.exp((t - 90) * 0.5);
                standardData.push(stdEntropy);
                
                // MBT model - memory persistence may prevent divergence
                const tempStress = Math.exp((currentTemp - 300) / 100);
                const criticalCollapse = 1 - Math.exp(-tempStress * t / 50);
                const memory = (1 - criticalCollapse) * presence * Math.pow(echo, 2);
                
                // MBT entropy with critical damping
                if (t > 85 && memory > 0.1) {
                    // Memory provides resistance to divergence
                    currentMbtEntropy = currentMbtEntropy + 0.1 * (1 - memory);
                } else {
                    currentMbtEntropy = calculateMbtEntropy(t, currentTemp, 0.1, currentMbtEntropy);
                }
                
                if (t > 0 && currentMbtEntropy < mbtData[t-1]) reorderCount++;
                
                mbtData.push(currentMbtEntropy);
                memoryData.push(memory);
                entropyData.push(currentMbtEntropy);
                coherenceData.push(1 - criticalCollapse);
            }
            
            updateChart(comparisonChart, timeSteps, [standardData, mbtData], 
                       ['Standard (Diverges)', 'MBT (Memory Damped)']);
            updateChart(memoryChart, timeSteps, [memoryData], ['Memory at Critical Point']);
            updateChart(entropyChart, timeSteps, [entropyData], ['MBT Entropy']);
            updateChart(coherenceChart, timeSteps, [coherenceData], ['Coherence']);
            
            document.getElementById('reorder-events').textContent = reorderCount;
            document.getElementById('final-memory').textContent = memoryData[memoryData.length - 1].toFixed(3);
        }
        
        // Hysteresis test - heating then cooling cycle
        function testHysteresis() {
            console.log("Testing hysteresis behavior...");
            const presence = parseFloat(document.getElementById('presence').value);
            const echo = parseFloat(document.getElementById('echo').value);
            
            timeSteps = [];
            memoryData = [];
            entropyData = [];
            coherenceData = [];
            standardData = [];
            mbtData = [];
            
            let currentMbtEntropy = 0.1;
            let memoryHistory = [];
            let reorderCount = 0;
            
            for (let t = 0; t <= 200; t++) {
                timeSteps.push(t);
                
                // Temperature cycle: heat up then cool down
                let currentTemp;
                if (t <= 100) {
                    currentTemp = 250 + (400 - 250) * (t / 100); // Heating
                } else {
                    currentTemp = 400 - (400 - 250) * ((t - 100) / 100); // Cooling
                }
                
                // Standard model - no hysteresis
                const stdEntropy = Math.abs(currentTemp - 325) * 0.01;
                standardData.push(stdEntropy);
                
                // MBT model - memory creates hysteresis
                const baseCollapse = 1 - Math.exp(-Math.abs(currentTemp - 325) / 50);
                
                // Memory of previous states
                memoryHistory.push(currentTemp);
                if (memoryHistory.length > 20) memoryHistory.shift();
                
                const memoryInfluence = memoryHistory.reduce((sum, temp) => 
                    sum + Math.exp(-Math.abs(temp - currentTemp) / 25), 0) / memoryHistory.length;
                
                const hysteresisCollapse = baseCollapse * (1 - memoryInfluence * 0.3);
                const memory = (1 - hysteresisCollapse) * presence * Math.pow(echo, 2);
                
                // MBT entropy with hysteresis
                const entropyChange = (currentTemp - 325) * 0.005 * (1 - memory * 0.5);
                currentMbtEntropy = Math.max(0.05, currentMbtEntropy + entropyChange);
                
                if (t > 0 && currentMbtEntropy < mbtData[t-1]) reorderCount++;
                
                mbtData.push(currentMbtEntropy);
                memoryData.push(memory);
                entropyData.push(currentMbtEntropy);
                coherenceData.push(1 - hysteresisCollapse);
            }
            
            updateChart(comparisonChart, timeSteps, [standardData, mbtData], 
                       ['Standard (No Hysteresis)', 'MBT (With Hysteresis)']);
            updateChart(memoryChart, timeSteps, [memoryData], ['Memory During Cycle']);
            updateChart(entropyChart, timeSteps, [entropyData], ['MBT Entropy Hysteresis']);
            updateChart(coherenceChart, timeSteps, [coherenceData], ['Coherence Cycle']);
            
            document.getElementById('reorder-events').textContent = reorderCount;
            document.getElementById('final-memory').textContent = memoryData[memoryData.length - 1].toFixed(3);
        }
        
        // Rapid quench test - sudden temperature drop
        function testQuench() {
            console.log("Testing rapid quench behavior...");
            const presence = parseFloat(document.getElementById('presence').value);
            const echo = parseFloat(document.getElementById('echo').value);
            
            timeSteps = [];
            memoryData = [];
            entropyData = [];
            coherenceData = [];
            standardData = [];
            mbtData = [];
            
            let currentMbtEntropy = 2.0; // Start high
            let reorderCount = 0;
            
            for (let t = 0; t <= 100; t++) {
                timeSteps.push(t);
                
                // Sudden quench at t=30
                const currentTemp = t < 30 ? 400 : 250;
                
                // Standard model - rapid entropy decrease then equilibrium
                let stdEntropy;
                if (t < 30) {
                    stdEntropy = 2.0;
                } else if (t < 40) {
                    stdEntropy = 2.0 - (t - 30) * 0.15; // Rapid drop
                } else {
                    stdEntropy = 0.5; // Equilibrium
                }
                standardData.push(Math.max(0.1, stdEntropy));
                
                // MBT model - memory resists rapid change initially
                if (t == 30) {
                    // Quench shock - memory tries to maintain state
                    const quenchShock = Math.exp(-presence * echo); // Memory resistance
                    currentMbtEntropy = currentMbtEntropy * quenchShock + 0.5 * (1 - quenchShock);
                } else if (t > 30 && t < 50) {
                    // Gradual adjustment with memory effects
                    const memoryResistance = Math.exp(-(t - 30) / 10);
                    currentMbtEntropy = currentMbtEntropy * (0.9 + 0.1 * memoryResistance) - 0.05;
                } else if (t >= 50) {
                    // Normal reordering behavior
                    currentMbtEntropy = calculateMbtEntropy(t - 50, currentTemp, 0.05, currentMbtEntropy);
                }
                
                currentMbtEntropy = Math.max(0.1, currentMbtEntropy);
                
                // Calculate memory and coherence
                const collapse = 1 - Math.exp(-Math.abs(currentTemp - 325) / 100);
                const memory = (1 - collapse) * presence * Math.pow(echo, 2);
                
                if (t > 0 && currentMbtEntropy < mbtData[t-1]) reorderCount++;
                
                mbtData.push(currentMbtEntropy);
                memoryData.push(memory);
                entropyData.push(currentMbtEntropy);
                coherenceData.push(1 - collapse);
            }
            
            updateChart(comparisonChart, timeSteps, [standardData, mbtData], 
                       ['Standard Quench', 'MBT Quench (Memory Lag)']);
            updateChart(memoryChart, timeSteps, [memoryData], ['Memory During Quench']);
            updateChart(entropyChart, timeSteps, [entropyData], ['MBT Entropy Quench']);
            updateChart(coherenceChart, timeSteps, [coherenceData], ['Coherence After Quench']);
            
            document.getElementById('reorder-events').textContent = reorderCount;
            document.getElementById('final-memory').textContent = memoryData[memoryData.length - 1].toFixed(3);
        }
        document.addEventListener('DOMContentLoaded', function() {
            initCharts();
            updateSliderDisplays();
            
            // Add event listeners for sliders
            ['temperature', 'presence', 'echo', 'phase-rate'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateSliderDisplays);
            });
        });
    </script>
</body>
</html>
